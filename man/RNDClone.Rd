% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RNDClone_fn.R
\docType{package}
\name{RNDClone}
\alias{RNDClone}
\title{RNDClone: Tumor Subclone Reconstruction Based on Integrating DNA and RNA Sequence Data}
\description{
The RNDClone package includes four major functions, which can be used for 
tumor subclone reconstruction (based on Bayesian inference and posterior Markov
chain Monte Carlo) with DNA and RNA sequence data. The four functions are:
\describe{
\item{\code{RNDClone_RJMCMC}}{}
\item{\code{RNDClone_PT}}{}
\item{\code{DClone_RJMCMC}}{}
\item{\code{RClone_RJMCMC}}{}
}
Use \code{?Function_Name} or \code{help(Function_Name)} to retrieve the 
documentation for a specific function. E.g., \code{?RNDClone_RJMCMC}.
}
\section{Author(s)}{

Tianjian Zhou, \email{tjzhou@uchicago.edu}
}

\examples{
library(RNDClone)

data(sim1a_C4_T4)

# Retrieve data
n = sim1a_C4_T4$n
N = sim1a_C4_T4$N
m = sim1a_C4_T4$m
M = sim1a_C4_T4$M
g_fun = sim1a_C4_T4$g_fun

set.seed(345)

# Run the trans-dimensional MCMC as described in the paper (may take a while, ~ 1 hr)
MCMC_spls = RNDClone_RJMCMC(n = n, N = N, m = m, M = M, g_fun = g_fun)

# For testing purpose, use (small number of iterations and burnin)
# MCMC_spls = RNDClone_RJMCMC(n = n, N = N, m = m, M = M, g_fun = g_fun, niter = 50, burnin = 200, thin = 2)

# Retrieve posterior samples of the parameters
C_spls = MCMC_spls$sample_list$C_spls
L_spls = MCMC_spls$sample_list$L_spls
Z_spls = MCMC_spls$sample_list$Z_spls
Lambda_spls = MCMC_spls$sample_list$Lambda_spls
W_spls = MCMC_spls$sample_list$W_spls

# Point estimate of C: posterior mode
C_hat = which.max(tabulate(C_spls))

# Point estimates of L, Z, W and Lambda: Maximum A Posteriori (MAP) conditional on C_hat
# First find which sample has the largest log-posterior
logpost_spls = MCMC_spls$sample_list$logpost_spls
logpost_spls[C_spls != C_hat] = -Inf
index_MAP = which.max(logpost_spls)
L_hat = L_spls[[index_MAP]]
Z_hat = Z_spls[[index_MAP]]
Lambda_hat = Lambda_spls[[index_MAP]]
# The last column of W_hat corresponds to w[t0] in the paper, which is used to capture random noise
W_hat = W_spls[[index_MAP]]

# End(Not run)
}
