% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RNDClone_fn.R
\name{RClone_RJMCMC}
\alias{RClone_RJMCMC}
\title{RClone trans-dimensional MCMC sampling}
\usage{
RClone_RJMCMC(
  M,
  C_min = 2,
  C_max = 7,
  g_fun = NULL,
  K_min = 1,
  K_max = 3,
  niter = 5000,
  burnin = 20000,
  thin = 2,
  Delta = 1.15^(9:0),
  tau = 0.99,
  alpha = 0.8,
  a_w = 1,
  b_w = 1,
  d = 1,
  d0 = 0.03,
  a_lambda = 1,
  b_lambda = 1,
  a_gamma_R = 1,
  b_gamma_R = NULL,
  a_nu_R = 1,
  b_nu_R = NULL,
  a_psi = NULL,
  b_psi = NULL,
  verbose = FALSE
)
}
\arguments{
\item{M}{A \code{S * T} matrix, where \code{M[s, t]} is the total number of
RNA reads at locus \code{s} for sample \code{t}.}

\item{C_min}{The prior lower bound for the number of subclones C; default is 2.}

\item{C_max}{The prior upper bound for the number of subclones C; default is 7.}

\item{g_fun}{A length \code{S} vector, where \code{g_fun[s]} is the index of 
the gene that locus \code{s} reside in. 
If not specified, \code{g_fun = 1:S} by default, i.e.,
each locus reside in a unique gene.}

\item{niter}{Number of trans-dimensional MCMC samples to be returned; default is 5000.}

\item{burnin}{Number of burn-in MCMC iterations; default is 20000.}

\item{thin}{Thinning factor for the MCMC sampling; default is 2, 
i.e., take one sample every two MCMC iterations.
(Note: the total number of MCMC iterations would be 
burnin + thinning * niter).}

\item{Delta}{A length I vector representing the (decreasing) temperatures used for 
parallel tempering. The last entry Delta[I] must be 1. The default value
is a length 10 vector, 1.15^(9:0).}

\item{tau}{The power of the likelihood in the power prior proposal; default is 0.99.}

\item{alpha}{A hyperparameter in the prior for C. Recall that C ~ Trunc-Geom(alpha),
where C is the number of subclones. The default value is alpha = 0.8.}

\item{a_w}{A hyperparameter in the prior for W. Default is 1. Recall that W is a 
 in the last column of W).
 The t-th row of W is \code{c(W[t, 1], ..., W[t, C], W[t, 0])}, the 
 population frequencies of the C subclones and the "background subclone".
 W[t, 1] ~ Beta(a_w, b_w), and 
(W[t, 0], W[t, 2], ..., W[t, C]) ~ Dirichlet(d0, d, ..., d).}

\item{b_w}{A hyperparameter in the prior for W. Default is 1.}

\item{d}{A hyperparameter in the prior for W. Default is 1.}

\item{d0}{A hyperparameter in the prior for W. Default is 0.03.}

\item{a_lambda}{A hyperparameter in the prior for Lambda. 
Recall that Lambda[g, c] ~ Gamma(a_lambda, b_lambda),
which is the RSGE of gene g in subclone c.
Default is 1.}

\item{b_lambda}{A hyperparameter in the prior for Lambda. 
Default is 1.}

\item{...}{Other hyperparameters. Have default values but can also be changed.}
}
\value{
A list of the following:
\describe{
\item{\code{sample_list}}{Again, a list of MCMC samples for the parameters.
\itemize{
  \item \code{C_spls} A length \code{niter} vector, MCMC samples of the number 
                      of subclones C.
  \item \code{Lambda_spls} A length \code{niter} list, MCMC samples of the gene 
                      expression matrix Lambda. Since the dimension of Lambda is 
                      changing at each iteration, 
                      \code{Lambda_spls[[j]]} is the sample at the j-th iteration.
  \item \code{W_spls} A length \code{niter} list, MCMC samples of the population 
                      frequency matrix W. Since the dimension of W is 
                      changing at each iteration, 
                      \code{W_spls[[j]]} is the sample at the j-th iteration.
  \item \code{logpost_spls} A length \code{niter} vector, log-posterior value
                            at each MCMC iteration.
}}
\item{\code{PT_AC_state_list}}{For keeping the current MCMC states at every temprature
                               and every possible C (number of subclones)}
}
}
\description{
\code{RClone_RJMCMC} implements the trans-dimensional Markov chain Monte Carlo (MCMC)  
sampling and parallel tempering described in the paper "RNDClone: Tumor Subclone 
Reconstruction Based on Integrating DNA and RNA Sequence Data"
if \strong{only RNA data are available}.
The function \code{RClone_RJMCMC(M, ...)} takes one
matrix, total RNA counts \code{M}, 
as input, and returns posterior MCMC samples (in a list). 
Compared to \code{RNDClone_RJMCMC}, \code{RClone_RJMCMC(M, ...)} cannot 
estimate DNA-related quantities such as L and Z.
}
\examples{
library(RNDClone)

data(sim1a_C4_T4)

# Retrieve data
M = sim1a_C4_T4$M
g_fun = sim1a_C4_T4$g_fun

set.seed(345)

# Run the trans-dimensional MCMC as described in the paper (may take a while, ~ 1 hr)
MCMC_spls = RClone_RJMCMC(M = M, g_fun = g_fun)

# For testing purpose, use (small number of iterations and burnin)
# MCMC_spls = RClone_RJMCMC(M = M, g_fun = g_fun, niter = 50, burnin = 200, thin = 2)

# Retrieve posterior samples of the parameters
C_spls = MCMC_spls$sample_list$C_spls
Lambda_spls = MCMC_spls$sample_list$Lambda_spls
W_spls = MCMC_spls$sample_list$W_spls

# Point estimate of C: posterior mode
C_hat = which.max(tabulate(C_spls))

# Point estimates of L, Z, W and Lambda: Maximum A Posteriori (MAP) conditional on C_hat
# First find which sample has the largest log-posterior
logpost_spls = MCMC_spls$sample_list$logpost_spls
logpost_spls[C_spls != C_hat] = -Inf
index_MAP = which.max(logpost_spls)
Lambda_hat = Lambda_spls[[index_MAP]]
# The last column of W_hat corresponds to w[t0] in the paper, which is used to capture random noise
W_hat = W_spls[[index_MAP]]

# End(Not run)
}
