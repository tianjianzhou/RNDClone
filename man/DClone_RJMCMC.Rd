% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RNDClone_fn.R
\name{DClone_RJMCMC}
\alias{DClone_RJMCMC}
\title{DClone trans-dimensional MCMC sampling}
\usage{
DClone_RJMCMC(
  n,
  N,
  C_min = 2,
  C_max = 7,
  K_min = 1,
  K_max = 3,
  niter = 5000,
  burnin = 20000,
  thin = 2,
  Delta = 1.15^(9:0),
  tau = 0.99,
  alpha = 0.8,
  a_w = 1,
  b_w = 1,
  d = 1,
  d0 = 0.03,
  a_pai = NULL,
  b_pai = NULL,
  a_zeta = NULL,
  b_zeta = NULL,
  a_gamma_D = 1,
  b_gamma_D = NULL,
  a_nu_D = 1,
  b_nu_D = NULL,
  a_phi = NULL,
  b_phi = NULL,
  verbose = FALSE
)
}
\arguments{
\item{n}{A \code{S * T} matrix, where \code{n[s, t]} is the number of variant
DNA reads at locus \code{s} for sample \code{t}.
Here, \code{S} is the number of nucleotide loci,
and \code{T} is the number of tissue samples.}

\item{N}{A \code{S * T} matrix, where \code{N[s, t]} is the total number of
DNA reads at locus \code{s} for sample \code{t}.}

\item{C_min}{The prior lower bound for the number of subclones C; default is 2.}

\item{C_max}{The prior upper bound for the number of subclones C; default is 7.}

\item{K_min}{The prior lower bound for the copy number l[s, c]; default is 1.}

\item{K_max}{The prior upper bound for the copy number l[s, c]; default is 3.}

\item{niter}{Number of trans-dimensional MCMC samples to be returned; default is 5000.}

\item{burnin}{Number of burn-in MCMC iterations; default is 20000.}

\item{thin}{Thinning factor for the MCMC sampling; default is 2, 
i.e., take one sample every two MCMC iterations.
(Note: the total number of MCMC iterations would be 
burnin + thinning * niter).}

\item{Delta}{A length I vector representing the (decreasing) temperatures used for 
parallel tempering. The last entry Delta[I] must be 1. The default value
is a length 10 vector, 1.15^(9:0).}

\item{tau}{The power of the likelihood in the power prior proposal; default is 0.99.}

\item{alpha}{A hyperparameter in the prior for C. Recall that C ~ Trunc-Geom(alpha),
where C is the number of subclones. The default value is alpha = 0.8.}

\item{a_w}{A hyperparameter in the prior for W. Default is 1. Recall that W is a 
 in the last column of W).
 The t-th row of W is \code{c(W[t, 1], ..., W[t, C], W[t, 0])}, the 
 population frequencies of the C subclones and the "background subclone".
 W[t, 1] ~ Beta(a_w, b_w), and 
(W[t, 0], W[t, 2], ..., W[t, C]) ~ Dirichlet(d0, d, ..., d).}

\item{b_w}{A hyperparameter in the prior for W. Default is 1.}

\item{d}{A hyperparameter in the prior for W. Default is 1.}

\item{d0}{A hyperparameter in the prior for W. Default is 0.03.}

\item{...}{Other hyperparameters. Have default values but can also be changed.}
}
\value{
A list of the following:
\describe{
\item{\code{sample_list}}{Again, a list of MCMC samples for the parameters.
\itemize{
  \item \code{C_spls} A length \code{niter} vector, MCMC samples of the number 
                      of subclones C.
  \item \code{L_spls} A length \code{niter} list, MCMC samples of the copy number 
                      matrix L. Since the dimension of L is changing at each iteration, 
                      \code{L_spls[[j]]} is the sample at the j-th iteration.
  \item \code{Z_spls} A length \code{niter} list, MCMC samples of the variant allele
                      number matrix Z. Since the dimension of Z is changing at each 
                      iteration, \code{Z_spls[[j]]} is the sample at the j-th iteration.
  \item \code{W_spls} A length \code{niter} list, MCMC samples of the population 
                      frequency matrix W. Since the dimension of W is 
                      changing at each iteration, 
                      \code{W_spls[[j]]} is the sample at the j-th iteration.
  \item \code{logpost_spls} A length \code{niter} vector, log-posterior value
                            at each MCMC iteration.
}}
\item{\code{PT_AC_state_list}}{For keeping the current MCMC states at every temprature
                               and every possible C (number of subclones)}
}
}
\description{
\code{DClone_RJMCMC} implements the trans-dimensional Markov chain Monte Carlo (MCMC)  
sampling and parallel tempering described in the paper "RNDClone: Tumor Subclone 
Reconstruction Based on Integrating DNA and RNA Sequence Data"
if \strong{only DNA data are available}.
The function \code{DClone_RJMCMC(n, N, ...)} takes two
matrices, variant DNA counts \code{n} and total DNA counts \code{N}, 
as input, and returns posterior MCMC samples (in a list). 
Compared to \code{RNDClone_RJMCMC}, \code{DClone_RJMCMC(n, N, ...)} cannot 
estimate RNA-related quantities such as Lambda (subclonal gene expression levels).
}
\examples{
library(RNDClone)

data(sim1a_C4_T4)

# Retrieve data
n = sim1a_C4_T4$n
N = sim1a_C4_T4$N

set.seed(345)

# Run the trans-dimensional MCMC as described in the paper (may take a while, ~ 1 hr)
MCMC_spls = DClone_RJMCMC(n = n, N = N)

# For testing purpose, use (small number of iterations and burnin)
# MCMC_spls = DClone_RJMCMC(n = n, N = N, niter = 50, burnin = 200, thin = 2)

# Retrieve posterior samples of the parameters
C_spls = MCMC_spls$sample_list$C_spls
L_spls = MCMC_spls$sample_list$L_spls
Z_spls = MCMC_spls$sample_list$Z_spls
W_spls = MCMC_spls$sample_list$W_spls

# Point estimate of C: posterior mode
C_hat = which.max(tabulate(C_spls))

# Point estimates of L, Z, W and Lambda: Maximum A Posteriori (MAP) conditional on C_hat
# First find which sample has the largest log-posterior
logpost_spls = MCMC_spls$sample_list$logpost_spls
logpost_spls[C_spls != C_hat] = -Inf
index_MAP = which.max(logpost_spls)
L_hat = L_spls[[index_MAP]]
Z_hat = Z_spls[[index_MAP]]
# The last column of W_hat corresponds to w[t0] in the paper, which is used to capture random noise
W_hat = W_spls[[index_MAP]]

# End(Not run)
}
