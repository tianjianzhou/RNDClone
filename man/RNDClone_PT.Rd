% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RNDClone_fn.R
\name{RNDClone_PT}
\alias{RNDClone_PT}
\title{RNDClone fixed-dimensional MCMC sampling}
\usage{
RNDClone_PT(
  n,
  N,
  m,
  M,
  C,
  g_fun = NULL,
  K_min = 1,
  K_max = 3,
  niter = 5000,
  burnin = 20000,
  thin = 2,
  Delta = 1.15^(9:0),
  a_w = 1,
  b_w = 1,
  d = 1,
  d0 = 0.03,
  a_lambda = 1,
  b_lambda = 1,
  a_pai = NULL,
  b_pai = NULL,
  a_zeta = NULL,
  b_zeta = NULL,
  a_gamma_D = 1,
  b_gamma_D = NULL,
  a_nu_D = 1,
  b_nu_D = NULL,
  a_gamma_R = 1,
  b_gamma_R = NULL,
  a_nu_R = 1,
  b_nu_R = NULL,
  a_phi = NULL,
  b_phi = NULL,
  a_psi = NULL,
  b_psi = NULL,
  verbose = FALSE
)
}
\arguments{
\item{n}{A \code{S * T} matrix, where \code{n[s, t]} is the number of variant
DNA reads at locus \code{s} for sample \code{t}.
Here, \code{S} is the number of nucleotide loci,
and \code{T} is the number of tissue samples.}

\item{N}{A \code{S * T} matrix, where \code{N[s, t]} is the total number of
DNA reads at locus \code{s} for sample \code{t}.}

\item{m}{A \code{S * T} matrix, where \code{m[s, t]} is the number of
variant RNA reads at locus \code{s} for sample \code{t}.}

\item{M}{A \code{S * T} matrix, where \code{M[s, t]} is the total number of
RNA reads at locus \code{s} for sample \code{t}.}

\item{C}{Pre-specified number of subclones. If no information is available, use
function \code{RNDClone_RJMCMC} to obtain an estimate of the number of
subclones \code{C} through trans-dimensional MCMC.}

\item{g_fun}{A length \code{S} vector, where \code{g_fun[s]} is the index of 
the gene that locus \code{s} reside in. 
If not specified, \code{g_fun = 1:S} by default, i.e.,
each locus reside in a unique gene.}

\item{K_min}{The prior lower bound for the copy number l[s, c]; default is 1.}

\item{K_max}{The prior upper bound for the copy number l[s, c]; default is 3.}

\item{niter}{Number of trans-dimensional MCMC samples to be returned; default is 5000.}

\item{burnin}{Number of burn-in MCMC iterations; default is 20000.}

\item{thin}{Thinning factor for the MCMC sampling; default is 2, 
i.e., take one sample every two MCMC iterations.
(Note: the total number of MCMC iterations would be 
burnin + thinning * niter).}

\item{Delta}{A length I vector representing the (decreasing) temperatures used for 
parallel tempering. The last entry Delta[I] must be 1. The default value
is a length 10 vector, 1.15^(9:0).}

\item{a_w}{A hyperparameter in the prior for W. Default is 1. Recall that W is a 
 in the last column of W).
 The t-th row of W is \code{c(W[t, 1], ..., W[t, C], W[t, 0])}, the 
 population frequencies of the C subclones and the "background subclone".
 W[t, 1] ~ Beta(a_w, b_w), and 
(W[t, 0], W[t, 2], ..., W[t, C]) ~ Dirichlet(d0, d, ..., d).}

\item{b_w}{A hyperparameter in the prior for W. Default is 1.}

\item{d}{A hyperparameter in the prior for W. Default is 1.}

\item{d0}{A hyperparameter in the prior for W. Default is 0.03.}

\item{a_lambda}{A hyperparameter in the prior for Lambda. 
Recall that Lambda[g, c] ~ Gamma(a_lambda, b_lambda),
which is the RSGE of gene g in subclone c.
Default is 1.}

\item{b_lambda}{A hyperparameter in the prior for Lambda. 
Default is 1.}

\item{tau}{The power of the likelihood in the power prior proposal; default is 0.99.}

\item{alpha}{A hyperparameter in the prior for C. Recall that C ~ Trunc-Geom(alpha),
where C is the number of subclones. The default value is alpha = 0.8.}

\item{...}{Other hyperparameters. Have default values but can also be changed.}
}
\value{
A list of the following:
\describe{
\item{\code{sample_list}}{Again, a list of MCMC samples for the parameters.
\itemize{
  \item \code{L_spls} A \code{S * C * niter} array, MCMC samples of the copy number 
                      matrix L. 
                      \code{L_spls[ , , j]} is the sample at the j-th iteration.
  \item \code{Z_spls} A \code{S * C * niter} array, MCMC samples of the variant allele
                      number matrix Z. 
                      \code{Z_spls[ , , j]} is the sample at the j-th iteration.
  \item \code{Lambda_spls} A \code{G * C * niter} array, MCMC samples of the gene 
                      expression matrix Lambda. 
                      \code{Lambda_spls[, , j]} is the sample at the j-th iteration.
  \item \code{W_spls} A \code{T * (C + 1) * niter} array, MCMC samples of the population 
                      frequency matrix W. 
                      \code{W_spls[, , j]} is the sample at the j-th iteration.
  \item \code{logpost_spls} A length \code{niter} vector, log-posterior value
                            at each MCMC iteration.
}}
\item{\code{PT_state_list}}{For keeping the current MCMC states at every temprature}
}
}
\description{
Implementing the parallel-tempering Markov chain Monte Carlo (MCMC) sampling 
(with a fixed number of subclones C) described in the paper 
"RNDClone: Tumor Subclone 
Reconstruction Based on Integrating DNA and RNA Sequence Data". 
The function \code{RNDClone_PT(n, N, m, M, C,...)} takes four
matrices, variant DNA counts \code{n}, total DNA counts \code{N}, 
variant RNA counts \code{m} and total RNA counts \code{M}, and the 
pre-specified number of subclones \code{C},
as input, and returns posterior MCMC samples (in a list).
}
\examples{
library(RNDClone)

data(sim1a_C4_T4)

# Retrieve data
n = sim1a_C4_T4$n
N = sim1a_C4_T4$N
m = sim1a_C4_T4$m
M = sim1a_C4_T4$M
g_fun = sim1a_C4_T4$g_fun

set.seed(345)

# Run the parallel-tempering MCMC as described in the paper (may take a while, ~ 20 min)
# Here we know the true C = 4, and we pre-specify it
MCMC_spls = RNDClone_PT(n = n, N = N, m = m, M = M, C = 4, g_fun = g_fun)

# For testing purpose, use (small number of iterations and burnin)
# MCMC_spls = RNDClone_PT(n = n, N = N, m = m, M = M, C = 4, g_fun = g_fun, 
                          niter = 50, burnin = 200, thin = 2)

# Retrieve posterior samples of the parameters
L_spls = MCMC_spls$sample_list$L_spls
Z_spls = MCMC_spls$sample_list$Z_spls
Lambda_spls = MCMC_spls$sample_list$Lambda_spls
W_spls = MCMC_spls$sample_list$W_spls

# Point estimates of L, Z, W and Lambda: Maximum A Posteriori (MAP)
# First find which sample has the largest log-posterior
logpost_spls = MCMC_spls$sample_list$logpost_spls
index_MAP = which.max(logpost_spls)
L_hat = L_spls[ , , index_MAP]
Z_hat = Z_spls[ , , index_MAP]
Lambda_hat = Lambda_spls[ , , index_MAP]
# The last column of W_hat corresponds to w[t0] in the paper, which is used to capture random noise
W_hat = W_spls[ , , index_MAP]

# End(Not run)
}
