% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RNDClone_fn.R
\name{RNDClone_RJMCMC}
\alias{RNDClone_RJMCMC}
\title{RNDClone trans-dimensional MCMC sampling}
\usage{
RNDClone_RJMCMC(
  n,
  N,
  m,
  M,
  C_min = 2,
  C_max = 7,
  g_fun = NULL,
  K_min = 1,
  K_max = 3,
  niter = 5000,
  burnin = 20000,
  thin = 2,
  Delta = 1.15^(9:0),
  tau = 0.99,
  alpha = 0.8,
  a_w = 1,
  b_w = 1,
  d = 1,
  d0 = 0.03,
  a_lambda = 1,
  b_lambda = 1,
  a_pai = NULL,
  b_pai = NULL,
  a_zeta = NULL,
  b_zeta = NULL,
  a_gamma_D = 1,
  b_gamma_D = NULL,
  a_nu_D = 1,
  b_nu_D = NULL,
  a_gamma_R = 1,
  b_gamma_R = NULL,
  a_nu_R = 1,
  b_nu_R = NULL,
  a_phi = NULL,
  b_phi = NULL,
  a_psi = NULL,
  b_psi = NULL,
  verbose = FALSE
)
}
\arguments{
\item{n}{A \code{S * T} matrix, where \code{n[s, t]} is the number of variant
DNA reads at locus \code{s} for sample \code{t}.
Here, \code{S} is the number of nucleotide loci,
and \code{T} is the number of tissue samples.}

\item{N}{A \code{S * T} matrix, where \code{N[s, t]} is the total number of
DNA reads at locus \code{s} for sample \code{t}.}

\item{m}{A \code{S * T} matrix, where \code{m[s, t]} is the number of
variant RNA reads at locus \code{s} for sample \code{t}.}

\item{M}{A \code{S * T} matrix, where \code{M[s, t]} is the total number of
RNA reads at locus \code{s} for sample \code{t}.}

\item{C_min}{The prior lower bound for the number of subclones C; default is 2.}

\item{C_max}{The prior upper bound for the number of subclones C; default is 7.}

\item{g_fun}{A length \code{S} vector, where \code{g_fun[s]} is the index of 
the gene that locus \code{s} reside in. 
If not specified, \code{g_fun = 1:S} by default, i.e.,
each locus reside in a unique gene.}

\item{K_min}{The prior lower bound for the copy number l[s, c]; default is 1.}

\item{K_max}{The prior upper bound for the copy number l[s, c]; default is 3.}

\item{niter}{Number of trans-dimensional MCMC samples to be returned; default is 5000.}

\item{burnin}{Number of burn-in MCMC iterations; default is 20000.}

\item{thin}{Thinning factor for the MCMC sampling; default is 2, 
i.e., take one sample every two MCMC iterations.
(Note: the total number of MCMC iterations would be 
burnin + thinning * niter).}

\item{Delta}{A length I vector representing the (decreasing) temperatures used for 
parallel tempering. The last entry Delta[I] must be 1. The default value
is a length 10 vector, 1.15^(9:0).}

\item{tau}{The power of the likelihood in the power prior proposal; default is 0.99.}

\item{alpha}{A hyperparameter in the prior for C. Recall that C ~ Trunc-Geom(alpha),
where C is the number of subclones. The default value is alpha = 0.8.}

\item{a_w}{A hyperparameter in the prior for W.}

\item{b_w}{A hyperparameter in the prior for W.}

\item{...}{Other hyperparameters.}
}
\value{
A list of the following:
\describe{
\item{\code{sample_list}}{Again, a list of MCMC samples for the parameters.
\itemize{
  \item \code{C_spls} A length \code{niter} vector, MCMC samples of the number 
                      of subclones C.
  \item \code{L_spls} A length \code{niter} list, MCMC samples of the copy number 
                      matrix L. Since the dimension of L is changing at each iteration, 
                      \code{L_spls[[j]]} is the sample at the j-th iteration.
  \item \code{Z_spls} A length \code{niter} list, MCMC samples of the variant allele
                      number matrix Z. Since the dimension of Z is changing at each 
                      iteration, \code{Z_spls[[j]]} is the sample at the j-th iteration.
  \item \code{Lambda_spls} A length \code{niter} list, MCMC samples of the gene 
                      expression matrix Lambda. Since the dimension of Lambda is 
                      changing at each iteration, 
                      \code{Lambda_spls[[j]]} is the sample at the j-th iteration.
  \item \code{W_spls} A length \code{niter} list, MCMC samples of the population 
                      frequency matrix W. Since the dimension of W is 
                      changing at each iteration, 
                      \code{W_spls[[j]]} is the sample at the j-th iteration.
  \item \code{logpost_spls} A length \code{niter} vector, log-posterior value
                            at each MCMC iteration.
}}
\item{\code{PT_AC_state_list}}{For keeping the current MCMC states at every temprature}
}
}
\description{
Implementing the trans-dimensional Markov chain Monte Carlo (MCMC) sampling 
and parallel tempering described in the paper "RNDClone: Tumor Subclone 
Reconstruction Based on Integrating DNA and RNA Sequence Data". 
The function \code{RNDClone_RJMCMC(n, N, m, M, ...)} takes four
matrices, variant DNA counts \code{n}, total DNA counts \code{N}, 
variant RNA counts \code{m} and total RNA counts \code{M},
as input, and returns posterior MCMC samples (in a list).
}
\examples{
library(RNDClone)

data(sim1a_C4_T4)

# Retrieve data
n = sim1a_C4_T4$n
N = sim1a_C4_T4$N
m = sim1a_C4_T4$m
M = sim1a_C4_T4$M
g_fun = sim1a_C4_T4$g_fun

set.seed(345)

# Run the trans-dimensional MCMC as described in the paper (may take a while, ~ 1 hr)
MCMC_spls = RNDClone_RJMCMC(n = n, N = N, m = m, M = M, g_fun = g_fun)

# For testing purpose, use (small number of iterations and burnin)
# MCMC_spls = RNDClone_RJMCMC(n = n, N = N, m = m, M = M, g_fun = g_fun, niter = 50, burnin = 200, thin = 2)

# Retrieve posterior samples of the parameters
C_spls = MCMC_spls$sample_list$C_spls
L_spls = MCMC_spls$sample_list$L_spls
Z_spls = MCMC_spls$sample_list$Z_spls
Lambda_spls = MCMC_spls$sample_list$Lambda_spls
W_spls = MCMC_spls$sample_list$W_spls

# Point estimate of C: posterior mode
C_hat = which.max(tabulate(C_spls))

# Point estimates of L, Z, W and Lambda: Maximum A Posteriori (MAP) conditional on C_hat
# First find which sample has the largest log-posterior
logpost_spls = MCMC_spls$sample_list$logpost_spls
logpost_spls[C_spls != C_hat] = -Inf
index_MAP = which.max(logpost_spls)
L_hat = L_spls[[index_MAP]]
Z_hat = Z_spls[[index_MAP]]
Lambda_hat = Lambda_spls[[index_MAP]]
# The last column of W_hat corresponds to w[t0] in the paper, which is used to capture random noise
W_hat = W_spls[[index_MAP]]

# End(Not run)
}
